@author Jörgen Brandt <brandjoe@hu-berlin.de>
@copyright 2016 Jörgen Brandt
@version 0.1.0
@title A generic Petri net OTP library
@see gen_pnet
@see cvm2
@reference <a href="https://github.com/joergen7/gen_pnet">Source code</a> hosted at GitHub.
@doc

Some applications exhibit behavioral patterns that lend themselves to Petri nets. The major advantage of modeling applications with Petri nets is that they provide a natural view on the concurrent behavior of an application. This is achieved by making explicit the preconditions for an operation to be carried out while leaving implicit how and when an operation is triggered and what other operations might run in parallel.

This OTP library is a framework for programming with Petri nets. It implements a very general form of Petri nets: non-elementary, (in theory) unbounded Petri nets. I.e., tokens may not only be markers but carry additional information. Furthermore, a place can hold any number of tokens not just one.

While many simulation libraries only mimic the concurrent behavior of Petri nets, the `gen_pnet' library allows the definition of nets with an arbitrary number of transitions competing for a place's tokens neither imposing order in the form of an orverarching loop nor otherwise constraining parallelism.

<h2>Quick Start</h2>

This Quick Start section provides an overview about how Petri nets are started, queried, and manipulated with the `gen_pnet' module. We demonstrate the module's API in terms of a cookie vending machine implemented in the `cvm2' module which is also part of this code repository. Then, we have a look at how the callback functions of the cookie vending machine are implemented.

<h3>Using the Cookie Vending Machine Example</h3>

<img src="cvm2.png" alt="cvm2" width="347" height="191px" />


In the following we work with a cookie vending machine example Petri net. The source code for this net is given in cvm2.erl.

First we compile the library and start an interactive Erlang shell using <a href="https://github.com/erlang/rebar3">rebar3</a>.

```
rebar3 shell
'''
Now, before trying out the `gen_pnet' module we import the record definitions from `gen_pnet.hrl' for better readability of the examples.
```
rr( "include/gen_pnet.hrl" ).
[token]
'''
We can start the cookie vending machine by using `gen_pnet:start_link/3'. Its first argument is the callback module that defines the cookie vending machine. It must implement all callback functions defined in the `gen_pnet' behaviour. The second argument is used to initialize the Petri net while the third argument is an option list, identical to the one used in the `gen_server:start_link/n' functions. `gen_pnet:start_link/3' returns the process id of the just created Petri net process.
```
{ok, Pid} = gen_pnet:start_link( cvm2, [], [] ).
{ok, <0.115.0>}
'''
Now that the Petri net is running we can query the content of its places with `gen_pnet:ls/2'. This Petri net has five places: `coin_slot', `cash_box', `signal', `compartment', and `storage'. Initially, all places are empty except the `storage' place which holds six cookie packages.
```
gen_pnet:ls( Pid, coin_slot ).
{ok, []}

gen_pnet:ls( Pid, cash_box ).
{ok, []}

gen_pnet:ls( Pid, signal ).
{ok, []}

gen_pnet:ls( Pid, compartment ).
{ok, []}

gen_pnet:ls( Pid, storage ).
{ok,[cookie_box,cookie_box,cookie_box]}

gen_pnet:ls( Pid, some_place_that_does_not_exist ).
{error,no_such_place}
'''
The way to use this cookie vending machine is to insert a coin by adding an according token to the `coin_slot' place. This is done with the `gen_pnet:add/2' function which takes a reference to a Petri net instance and a token which is added to the net.
```
gen_pnet:add( Pid, coin_slot, coin ).
ok
'''
The effect of inserting a coin should be that the coin has wandered to the `cash_box' place, leaving the `coin_slot' place empty again. Also, a cookie token should have appeared in the formerly empty `compartment' place while the number of cookie packages in the `storage' place should have been reduced by 1. We can check this by querying the places as previously.
```
gen_pnet:ls( Pid, cash_box ). 
{ok,[coin]}

gen_pnet:ls( Pid, compartment ).
{ok,[cookie_box]}

gen_pnet:ls( Pid, storage ).
{ok,[cookie_box,cookie_box]}
'''
<h3>Implementing the Callback Functions</h3>

In the previous section we showed how the `gen_pnet' API can be used to create and use predefined Petri nets. Now, let us have a look at the callback functions that need to be implemented to define a Petri net. These are the six callbacks
<ul>
  <li>`init/1' which gives the initial marking of the net</li>
  <li>`place_lst/0', `trsn_lst/0', and `preset/1' which define the net structure</li>
  <li>`enum_consume_lst/3' which determines when a transition is enabled and what tokens it would consume if it were to fire</li>
  <li>`fire/3' which defines what happens when a transition actually fires and what tokens it produces</li>
</ul>
We have a look at each of them in turn.

<h4>init/1</h4>

The `init/1' function gives us the chance to define the initial marking of the Petri net in the form of a token list. Additionally, we can create a user info data structure which is handed also to the functions `enum_consume_lst/3' and `fire/3'.

```
init( _InitArg ) ->
  InitMarking = #{ storage => [cookie_box, cookie_box, cookie_box] },
  {ok, InitMarking, []}.
'''
<h4>place_lst/0</h4>
```
place_lst() ->
  [coin_slot, cash_box, signal, storage, compartment].
'''
<h4>trsn_lst/0</h4>
```
trsn_lst() -> [a, b].
'''
<h4>preset/1</h4>
```
preset( a ) -> [coin_slot];
preset( b ) -> [signal, storage].
'''
<h4>enum_consume_lst/3</h4>
```
enum_consume_map( a, #{ coin_slot := CLst }, _UserInfo ) ->
  [#{ coin_slot => [C] } || C <- CLst];

enum_consume_map( b, #{ signal := SgLst, storage := StLst }, _UserInfo ) ->
  [#{ signal => [Sg], storage => [St] } || Sg <- SgLst, St <- StLst].
'''
<h4>fire/3</h4>
The `fire/3' function defines what happens when a given transition fires and what tokens are produced. As arguments it takes the name of the transition, a list of tokens to be consumed which is a randomly selected list from the lists returned by `enum_consume_lst/3', as well as the user info data structure as returned by the `init/1' function.

The cookie vending machine has two transitions `a' and `b'. The `fire/3' function has to defined for both transitions. Transition `a' always consumes single coin tokens.
```
fire( a, _ConsumeMap, _UserInfo ) ->
  #{ signal => [sig], cash_box => [coin] };

fire( b, _ConsumeMap, _UserInfo ) ->
  #{ compartment => [cookie_box]}.
'''
