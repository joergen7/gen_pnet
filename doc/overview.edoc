@author Jorgen Brandt <joergen.brandt@onlinehome.de>
@copyright 2016 Jorgen Brandt
@version 0.1.1
@title A generic Petri net OTP library.
@doc


This Quick Start section provides an overview about how Petri nets are started, queried, and manipulated with the `gen_pnet' module. We demonstrate the module's API in terms of a cookie vending machine implemented in the `cvm2' module which is also part of this code repository. Then, we have a look at how the callback functions of the cookie vending machine are implemented.

<h3>Using the Cookie Vending Machine Example</h3>

<img src="cvm2.png" alt="cvm2" width="347" height="191px" />


In the following we work with a cookie vending machine example Petri net. The source code for this net is given in cvm2.erl.

First we compile the library and start an interactive Erlang shell using <a href="https://github.com/erlang/rebar3">rebar3</a>.

```
rebar3 shell
'''
We can start the cookie vending machine by using `gen_pnet:start_link/3'. Its first argument is the callback module that defines the cookie vending machine. It must implement all callback functions defined in the `gen_pnet' behaviour. The second argument is used to initialize the Petri net while the third argument is an option list, identical to the one used in the `gen_server:start_link/n' functions. `gen_pnet:start_link/3' returns the process id of the just created Petri net process.
```
{ok, Pid} = gen_pnet:start_link( cvm2, [], [] ).
{ok, <0.115.0>}
'''
Now that the Petri net is running we can query the content of its places with `gen_pnet:ls/2'. This Petri net has five places: `coin_slot', `cash_box', `signal', `compartment', and `storage'. Initially, all places are empty except the `storage' place which holds six cookie packages.
```
gen_pnet:ls( Pid, coin_slot ).
{ok, []}

gen_pnet:ls( Pid, cash_box ).
{ok, []}

gen_pnet:ls( Pid, signal ).
{ok, []}

gen_pnet:ls( Pid, compartment ).
{ok, []}

gen_pnet:ls( Pid, storage ).
{ok,[cookie_box,cookie_box,cookie_box]}

gen_pnet:ls( Pid, some_place_that_does_not_exist ).
{error,no_such_place}
'''
The way to use this cookie vending machine is to insert a coin by adding an according token to the `coin_slot' place. This is done with the `gen_pnet:add/2' function which takes a reference to a Petri net instance and a token which is added to the net.
```
gen_pnet:add( Pid, coin_slot, coin ).
ok
'''
The effect of inserting a coin should be that the coin has wandered to the `cash_box' place, leaving the `coin_slot' place empty again. Also, a cookie token should have appeared in the formerly empty `compartment' place while the number of cookie packages in the `storage' place should have been reduced by 1. We can check this by querying the places as previously.
```
gen_pnet:ls( Pid, cash_box ). 
{ok,[coin]}

gen_pnet:ls( Pid, compartment ).
{ok,[cookie_box]}

gen_pnet:ls( Pid, storage ).
{ok,[cookie_box,cookie_box]}
'''
<h3>Implementing the Callback Functions</h3>

In the previous section we showed how the `gen_pnet' API can be used to create and use predefined Petri nets. Now, let us have a look at the callback functions that need to be implemented to define a Petri net. These are the six callbacks
<ul>
  <li>`init/1' which gives the initial marking of the net</li>
  <li>`place_lst/0', `trsn_lst/0', and `preset/1' which define the net structure</li>
  <li>`enum_consume_lst/3' which determines when a transition is enabled and what tokens it would consume if it were to fire</li>
  <li>`fire/3' which defines what happens when a transition actually fires and what tokens it produces</li>
</ul>
We have a look at each of them in turn.

<h4>init/1</h4>

The `init/1' function gives us the chance to define the initial marking of the Petri net in the form of a token list. Additionally, we can create a user info data structure which is handed also to the functions `enum_consume_lst/3' and `fire/3'.

```
init( _InitArg ) ->
  InitMarking = #{ storage => [cookie_box, cookie_box, cookie_box] },
  {ok, InitMarking, []}.
'''
<h4>place_lst/0</h4>
```
place_lst() ->
  [coin_slot, cash_box, signal, storage, compartment].
'''
<h4>trsn_lst/0</h4>
```
trsn_lst() -> [a, b].
'''
<h4>preset/1</h4>
```
preset( a ) -> [coin_slot];
preset( b ) -> [signal, storage].
'''
<h4>enum_consume_map/3</h4>
```
enum_consume_map( a, #{ coin_slot := CLst }, _UserInfo ) ->
  [#{ coin_slot => [C] } || C <- CLst];

enum_consume_map( b, #{ signal := SgLst, storage := StLst }, _UserInfo ) ->
  [#{ signal => [Sg], storage => [St] } || Sg <- SgLst, St <- StLst].
'''
<h4>fire/3</h4>
The `fire/3' function defines what happens when a given transition fires and what tokens are produced. As arguments it takes the name of the transition, a list of tokens to be consumed which is a randomly selected list from the lists returned by `enum_consume_lst/3', as well as the user info data structure as returned by the `init/1' function.

The cookie vending machine has two transitions `a' and `b'. The `fire/3' function has to defined for both transitions. Transition `a' always consumes single coin tokens.
```
fire( a, _ConsumeMap, _UserInfo ) ->
  #{ signal => [sig], cash_box => [coin] };

fire( b, _ConsumeMap, _UserInfo ) ->
  #{ compartment => [cookie_box]}.
'''
